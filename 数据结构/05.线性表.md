# 概念
线性表是n个数据元素的有限序列，其中n个数据是相同数据类型的。

# 特点
线性表中元素的个数n（n≥0）定义为线性表的长度，当n=0时称之为空表。
对于非空的线性表或线性结构，其特点是：
- 存在唯一的一个被称作“第一个”的数据元素；
- 存在唯一的一个被称作“最后一个”的数据元素；
- 除第一个元素外，结构中的每个数据元素均只有一个==前驱==；
- 除最后一个元素外，结构中的每个数据元素均只有一个==后继==。

# 顺序表
用一组连续的内存单元依次存储线性表的各个元素，也就是说，逻辑上相邻的元素，实际的物理存储空间也是连续的。

## 定义
```c
#include <stdio.h>
#define MAXSIZE 100

typedef int ElemType;

typedef struct
{
ElemType *data;
int length;
}SeqList;
```

## 动态分配内存地址初始化
```c
SeqList *initList()
{
    SeqList *L = (SeqList *)malloc(sizeof(SeqList));
    L->data = (ElemType *)malloc(sizeof(ElemType) * MAXSIZE);
    L->length = 0; // 初始化
    return L;
}
```

## 在尾部添加元素
```c
int appendElem(SeqList* L,ElemType e)//在尾部添加元素
{
    if(L->length>=MAXSIZE)                                
    {
        printf("顺序表已满！");
        return 0;
    }
    L->data[L->length]=e;
    L->length++;
    return 1;                                     
}
```

## 遍历顺序表
```c
void listElem(SeqList* L)
{                                           
	for(int i=0;i<L->length;i++)
    {
        printf("%d\t",L->data[i]);
    }
        printf("\n");
}
```

## 插入元素
```c
int insertElem(SeqList* L,int pos,ElemType e)
{
    if(L->length>=MAXSIZE)
    {
        printf("顺序表已满！");
        return 0;
    }
    else if(pos<1||pos>L->length)
    {
        printf("插入位置错误！");
        return 0;
    }
     else
    {
        for(int i=L->length-1;i>=pos-1;i--)
        {
            L->data[i+1]=L->data[i];
		    L->data[pos-1]=e;
            L->length++;
        }
	    return 1; 
	}
}
```

## 删除元素
```c
int deleteElem(SeqList *L, int pos, ElemType *e) // 删除指定元素
{

    *e = L->data[pos - 1];

    if (L->length == 0)
    {
        printf("顺序表为空表！");
        return 0;
    }

    if (pos < 1 || pos > L->length)
    {
        printf("删除位置错误");
        return 0;
    }
    else
    {
        for (int i = pos; i < L->length; i++)
        {
            L->data[i - 1] = L->data[i];
        }
        L->length--;
        return 1;
    }
}
```

## 查找
```c
int findElem(SeqList *L, ElemType e)
{
    if (L->length == 0)
    {
        printf("顺序表为空！");
        return 0;
    }
    for (int i = 0; i < L->length; i++)
    {
        if (L->data[i] == e)
        {
            return i + 1;
        }
    }
    return 0;
}
```

## 主函数
```c
int main()
{
    // 声明一个顺序表并初始化
    SeqList *list = initList();
    printf("初始化成功，目前长度占用为：%d\n", list->length);
    printf("目前占用%zu字节\n", sizeof(list->data));

    appendElem(list, 88);
    appendElem(list, 10);
    appendElem(list, 86);
    appendElem(list, 99);
    insertElem(list, 2, 100);
    listElem(list);

    ElemType delData;
    deleteElem(list, 3, &delData);
    printf("被删除的数据为:%d\n", delData);
    listElem(list);

    printf("查找99的位置：%d\n", findElem(list, 99));

    free(list->data);
    free(list);

    return 0;
}
```

# 链表
## 特点
- 线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。
- 为了表示每个数据元素 a_i 与其直接后继数据元素 a_{i+1} 之间的逻辑关系，对数据元素 a_i 来说，除了其本身的信息之外，还需要存储一个指示其直接后继的信息（直接后继的存储位置）。这两部分信息组成数据元素 a_i 的存储映像，称为节点（node）。
- 结点包括两个域：其中存储数据元素信息的称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称作指针或链。

## 单链表
### 定义
```c
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;
typedef struct node
{
    ElemType data;
    struct node* next;
}Node;
```

### 初始化
```c
Node* initList()
{
    Node* head=(Node*)malloc(sizeof(Node));
    head->data=0;
    head->next=NULL;
    return head;
}
```

### 头插法
```c
int insertHead(Node* L,ElemType e)//头插法
{
    Node* p=(Node*)malloc(sizeof(Node));
    p->data=e;
    p->next=L->next;//顺序不能乱
    L->next=p;
    return 1;
}
```
> [!warning]
> 头插法的顺序与排列的顺序是相反的


### 遍历
```c
void listNode(Node* L)
{
    Node* p=L->next;
    while(p!=NULL)
    {
    printf("%d\t",p->data);
    p=p->next;
    }
    printf("\n");
}
```

### 尾插法
```c
Node *getTail(Node *L) // 寻找尾部节点
{
    Node *p = L;
    while (p->next != NULL)
    {
        p = p->next;
    }
    return p;
}

Node *insertTail(Node *tail, ElemType e)
{
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = e;
    tail->next = p;
    p->next = NULL;
    return p;
}
```

### 插入节点
```c
int insertNode(Node* L,int pos,ElemType e)
{
    //找到相应节点的位置
    Node* p=L;
    for(int i=0;i<pos-1;i++)
    {
        p=p->next;
        if(p==NULL)return 0;
    }

    //插入节点
    Node* q=(Node*)malloc(sizeof(Node));
    q->data=e;
    q->next=p->next;
    p->next=q;
    return 1;
}
```

### 删除节点
```c
int deleteNode(Node* L,int pos)
{
    //找到要删除节点的前驱
    Node* p=L;
    for(int i=0;i<pos-1;i++)
    {
    p=p->next;
    if(p==NULL)return 0;
    }
    if(p->next==NULL)//意味着删除的位置无节点
    {
    printf("要删除的节点错误！");
    return 0;
    }

    Node* q=p->next;//q为删除节点的地址
    p->next=q->next;
    free(q);
    return 0;
}
```

### 获取链表长度
```c
int listLength(Node* L)
{
    Node* p=L;
    int len=0;
    while(p!=NULL)
    {
        p=p->next;
        len++;
    }
    return len;
}
```

### 释放链表
```c
void freeList(Node* L)
{
    Node* p=L->next;
    Node* q;
    while(p!=NULL)
    {
        q=p->next;
        free(p);
        p=q;
    }
    L->next=NULL;
}
```

### 主函数
```c
int main()
{
    Node *list = initList();
    Node *tail = getTail(list);

    tail = insertTail(tail, 10);
    tail = insertTail(tail, 20);
    tail = insertTail(tail, 30);

    listNode(list);

    insertNode(list,2,15);
    listNode(list);

    deleteNode(list,2);
    listNode(list);
    printf("链表长度为:%d\n",listLength(list));
    freeList(list);
    printf("链表长度为:%d\n",listLength(list));

    return 0;
}
```

### 使用双指针找到倒数第k个节点
```c
void findNodeFS(Node* L,int k)
{
    Node* fast=L->next;
    Node* slow=L->next;//先让快慢指针位于同一位置
    for(int i=0;i<k;i++)fast=fast->next;//移动快指针与慢指针相隔k
    while(fast!=NULL)
    {
        fast=fast->next;
        slow=slow->next;//一起移动
    }
    printf("倒数第%d个节点值为%d\n",k,slow->data);
}
```

### 删除绝对值相同的节点（以空间换时间）
```c
void deleteAbsNode(Node *L, int n) // 删除绝对值相同的节点
{
	Node* p=L;
    int index; // 作为数组下标使用
    int* q=(int*)malloc(sizeof(int)*(n+1));
    // 遍历数组，初始化为0
    for(int i=0; i<n+1;i++)
    {
        *(q+i)=0;
    }
    while(p->next!=NULL)
    {
        index=abs(p->next->data);
        if(*(q+index)==0)
        {
            *(q+index)= 1;
            p=p->next;
        }
        else
        {
            Node* temp=p->next;
            p->next=temp->next;
            free(temp);
        }
    }
    free(q);
}
```

### 反转链表
```c
Node *reverseList(Node *head) // 反转列表
{
    // 建立三个指针，分别指向NULL，头节点的下一个地址，下下个地址
    Node *first = NULL;
    Node *second = head->next;
    Node *third; // 该指针需要加限定条件：second不能为空

    while (second != NULL)
    {
        third = second->next;
        second->next = first; // 调转链表的方向
        // 移动三个指针
        first = second;
        second = third;
        // 无需third = second->next，179行有
    }
    // 创建新的头节点
    Node *hd = initList();
    hd->next = first;
    return hd;
}
```

### 删除中间节点
```c
void delMiddleNode(Node *head) // 删除中间节点
{
    // 依旧使用快慢指针法
    // 快指针走两步的同时，慢指针走一步
    // 当快指针=NULL或下一节点为NULL，慢指针为删除节点的前一个地址
    Node* fast=head->next;
    Node* slow=head;
    while(fast!=NULL&&fast->next!=NULL)
    {
        fast=fast->next->next;
        slow=slow->next;
    }
    // 找到删除节点
    Node *q=slow->next;
    slow->next=q->next;
    free(q);
}
```

## 循环链表
### 特点
循环链表是另一种形式的链式存储结构，其特点是表中最后一个节点的指针域指向头节点，整个链表形成一个环。
>[!note]
>判别指针p是否指向尾表节点的终止条件：==p!=L或p->next!=L==

### 判断链表是否有环
```c
int isCycle(Node *head)
{
    Node *fast = head;
    Node *slow = head; // 使快慢指针在同一起点

    while (fast != NULL && fast->next != NULL)
    {
        fast = fast->next->next;
        slow = slow->next;

        if (fast == slow)
        {
            return 1;
        }
    }
    return 0;
}
```

### 找到链表循环入口
```c
// 判断循环链表的循环入口
Node *findBegin(Node *head)
{
    Node *fast = head;
    Node *slow = head;
    
    do
    {//第一次循环，快指针2，慢指针1
        fast = fast->next->next;
        slow = slow->next;
    } while (fast != slow);

    slow = head;
  
    while (fast != slow)
    {
        fast = fast->next;//第二次循环，都走1
        slow = slow->next;
    }
    return slow;
}
```

## 双向链表
### 特点
为了克服单链表这种单向性的缺点，可利用双向链表。在双向链表的节点中有两个指针域，一个指向直接后继，另一个指向直接前驱。

### 定义
```c
typedef int ElemType;
typedef struct node
{
    ElemType data;
    struct node *prev,*next;
}Node;
```

### 初始化
```c
Node *initNode()
{
    Node *head = (Node *)malloc(sizeof(Node));
    head->data = 0;
    head->next = NULL;
    head->prev = NULL;
    return head;
}
```

### 头插法
```c
void insertHead(Node *head, ElemType x)
{
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = x;
    p->prev = head;
    p->next = head->next;
    if (head->next != NULL)head->next->prev = p;
    head->next = p;
}
```

### 遍历
```c
void listNode(Node *head)
{
    Node *p = head;
    while (p->next != NULL)
    {
        p = p->next;
        printf("%d\t", p->data);
    }
    printf("\n");
}
```

### 尾插法
```c
Node *getTail(Node *head)
{
    Node *p = head;
    while (p->next != NULL)
    {
        p = p->next;
    }
    return p;
}

 Node *insertTail(Node *tail, ElemType x)
{
    Node *p = (Node *)malloc(sizeof(Node))
    p->data = x;
    p->prev = tail;
    tail->next = p;
    p->next = NULL;

    return p;
}
```

### 插入节点
```c
int insertNode(Node *head, int pos, ElemType x) // 指定位置插入节点
{
    Node *p = head;
    for (int i = 0; i < pos - 1; i++)
    {
        p = p->next; // p为要插入位置的前置节点
        if (p == NULL)return 0;
    }
    Node *q = (Node *)malloc(sizeof(Node));
    q->data = x;
    q->prev = p;
    q->next = p->next;

    p->next->prev = q;
    p->next = q;
    
    return 1;
}
```

### 删除节点
```c
int deleteNode(Node *head, int pos)
{
    Node *p = head;
    for (int i = 0; i < pos - 1; i++)
    {
        p = p->next; // p为要删除位置的前置节点
        if (p == NULL)return 0;
    }
    if (p->next == NULL)
    {
        printf("要删除的节点位置错误\n");
        return 0;
    }

    Node *q = p->next;
    p->next = q->next;
    q->next->prev = p;
    free(q);

    return 1;
}
```

### 释放链表
```c
void freeList(Node* L)
{
        Node* p=L->next;
        Node* q;
        while(p!=NULL)
        {
                q=p->next;
                free(p);
                p=q;
        }
        L->next=NULL;
}
```


---

下一节：[[06.栈和队列]]
