# 概念
## 排序
将一组数据元素按照某种规则（通常是关键字的大小）重新排列成有序的过程。

对于不同的排序算法，除了要掌握算法的实现思想及具体实现外，我们需要关注排序算法的三个核心指标：
1. **时间复杂度**：排序一组规模为 n 的数据，算法需要执行多少次基本操作？这会直接影响排序效率。
2. **空间复杂度**：排序过程中需要使用多少额外的内存空间？
3. **排序的稳定性**：排序前后，相等元素之间的相对顺序是否保持不变？
# 算法
## 冒泡排序
```c
// 交换数组中下标为 m 和 n 的两个元素的值
void swap(int* data, int m, int n)
{
    int temp = data[m];
    data[m] = data[n];
    data[n] = temp;
}

// 实现冒泡排序：将数组 data 中的元素按升序排列
void bubbleSort(int* data, int len)
{
    // 外层循环控制“趟数”，共需 len 次比较（严格来说是 len - 1 次）
    for (int i = 0; i < len; i++)
    {
        // 内层循环控制每趟中相邻元素的比较和交换
        // 每次比较到 len - i - 1，因为右侧已经排好序
        for (int j = 0; j < len - i - 1; j++)
        {
            // 如果前一个元素比后一个大，则交换它们
            if (data[j] > data[j + 1])
            {
                swap(data, j, j+1); // 调用 swap 函数进行交换
            }
        }
    }
}
```

## 插入排序
```c
// 插入排序函数
void insertSort(int* data, int len)
{
    int key; // 用于暂存当前待插入的元素
    for (int i = 1; i < len; i++) // 从第二个元素开始逐个插入
    {
        key = data[i];           // 将当前元素保存为 key
        int j = i - 1;           // 从已排序列的最后一个元素开始向前比较

        // 向前查找插入位置，移动比 key 大的元素
        while (j >= 0 && data[j] > key)
        {
            data[j+1] = data[j]; // 将比 key 大的元素后移
            j--;                 // 向前继续比较
        }

        // 找到插入位置后，将 key 插入
        data[j+1] = key;
    }
}
```

## 折半查找排序
```c
void binaryInsertSort(int* data, int len)
{
    int low, high, mid;
    int key;
    // 从第二个元素开始遍历，将其插入到前面已经排好序的子序列中
    for (int i = 1; i < len; i++)
    {
        key = data[i];          // 记录当前待插入的值
        low = 0;                // 设置当前有序序列的最小下标
        high = i - 1;           // 设置当前有序序列的最大下标
        // 使用折半查找法找出 key 应该插入的位置（即 low 最终的位置）
        while (low <= high)
        {
            mid = (low + high) / 2;
            if (data[mid] > key)
            {
                high = mid - 1; // 插入点在左半边
            }
            else
            {
                low = mid + 1;  // 插入点在右半边
            }
        }
        // 从后往前依次将大于 key 的元素后移，为 key 腾出位置
        int j = i - 1;
        while (j >= low)
        {
            data[j+1] = data[j];
            j--;
        }
        // 插入 key 到正确的位置
        data[low] = key;
    }
}
```

## 简单选择排序
```c
// 简单选择排序函数
void selectSort(int* data, int len)
{
    int min;
    // 外层循环：控制每一轮的起始位置
    for (int i = 0; i < len; i++)
    {
        // 假设当前位置 i 是最小值
        min = i;
        // 内层循环：从当前位置 i 向后寻找最小值的位置
        for (int j = i; j < len; j++)
        {
            // 如果发现比当前最小值还小的元素，更新最小值的位置
            if (data[min] > data[j])
            {
                min = j;
            }
        }
        // 如果找到的最小值不是当前位置，则进行交换
        if (i != min)
        {
            swap(data, i, min);
        }
    }
}
```

## 堆排序
### 概念
#### 堆
这里的 “堆” 不是平时程序中提到的 “内存堆区”，而是一种满足特定性质的树状结构。
在堆排序中，我们通常使用的是：
- **大根堆 / 最大堆**：每个节点都大于等于其子节点。
- **小根堆 / 最小堆**：每个节点都小于等于其子节点。

#### 堆排序
1.根据待排序的数组，构建二叉树（通常是完全二叉树）。
2.建堆：从最后一个非叶子节点开始向前遍历，每个节点都执行一次向下调整，最终构成一个大根堆。
3.排序:不断将堆顶（最大值）放到数组末尾，并重新调整剩下部分为大根堆。

### 算法
```c
// 交换数组中下标为 m 和 n 的两个元素的值
void swap(int* data, int m, int n)
{
    int temp = data[m];
    data[m] = data[n];
    data[n] = temp;
}
// 向下调整堆（从 root 开始，len 为当前堆的大小）
void adjust(int* data, int root, int len)
{
    int child;
    int temp = data[root];  // 保存当前根节点的值
    child = 2 * root;       // 左孩子下标

    // 只要存在孩子节点
    while (child <= len)
    {
        // 如果有右孩子，且右孩子比左孩子大，则选右孩子
        if (child < len && data[child] < data[child+1])
        {
            child++;  // 右孩子下标
        }
        // 如果当前节点比较大，不需要调整
        if (temp > data[child])
        {
            break;
        }
        // 将子节点的值上移
        data[child/2] = data[child];
        // 继续向下调整
        child = child * 2;
    }
    // 把原 root 的值放到最终位置
    data[child/2] = temp;
}
// 堆排序主函数
void heapSort(int* data, int len)
{
    // 1. 建堆过程：从最后一个非叶子节点开始向上调整
    for (int i = len / 2; i > 0; i--)
    {
        adjust(data, i, len);
    }

    // 2. 排序过程：将堆顶最大值依次交换到数组末尾，并调整剩余部分为大根堆
    for (int i = len; i > 1; i--)
    {
        swap(data, 1, i);          // 将当前最大值（堆顶）移到末尾
        adjust(data, 1, i-1);      // 对剩余部分重新建堆
    }
}
```