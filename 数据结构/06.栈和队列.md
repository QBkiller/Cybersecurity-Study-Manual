# 定义
## 栈
==栈==是限定仅在表尾进行插入或删除的线性表。
对于栈来说，表尾端称为==栈顶==，表头短称为==栈底==。
不含元素的空表称为==空栈==。

## 队列
==队列==是一种==先进先出==的线性表。它只允许在表的一端进行插入，而在另一端删除元素。在队列中，允许插入的一端被称为==队尾==，允许删除的一端称为==对头==。

## 递归
在函数的使用过程中，自己调用自己

# 栈
## 栈的顺序结构
### 定义
```c
#define MAXSIZE 100

typedef int ElemType;
typedef struct
{
    ElemType data[MAXSIZE];
    int top; // 栈顶
} Stack;
```

### 初始化
```c
void initStack(Stack *s)
{
    s->top = -1; // top为-1，应为数组初始下标为0
}
```

### 判断空栈
```c
int isEmpty(Stack *s)
{
    if (s->top == -1)
    {
        printf("栈为空\n");
        return 1;
    }
    else
        return 0;
}
```

### 进栈/压栈
```c
int push(Stack *s, ElemType e)
{
    if (s->top >= MAXSIZE - 1)
    {
        printf("栈满\n");
        return 0;
    }
    s->top++;
    s->data[s->top] = e;
    return 1;
}
```

### 出栈
```c
int pop(Stack *s, ElemType *e) // 第二个参数可获取出栈地址
{
    if (s->top == -1)
    {
        printf("栈为空\n");
        return 0;
    }
    *e = s->data[s->top];
    s->top--; // 出栈核心操作
    return 1;
}
```

### 获取栈顶元素
```c
int getTop(Stack *s, ElemType *e)//实际上获取*e，top的指针
{
    if (s->top == -1)
    {
        printf("栈为空\n");
        return 0;
    }
    *e = s->data[s->top];
    return 1;
}
```

### 动态分配内存
```c
define MAXSIZE 100
typedef int ElemType;
typedef struct
{
	ELemType *data;
	int top;
}Stack;

Stack *initStack()
{
	Stack *s=(Stack*)malloc(sizeof(Stacks));
	s->data=(ELemType*)malloc(sizeof(ELemType)*MAXSIZE);
	s->top=-1;
	return s;
```

## 栈的链式结构
### 定义
```c
#include <stdio.h>
#include <stdlib.h>
  
typedef int ElemType;
typedef struct stack
{
    ElemType data;
    struct stack *next;
} Stack;
```

### 初始化
```c
Stack *initStack()
{
    Stack *s = (Stack *)malloc(sizeof(Stack));
    s->data = 0;
    s->next = NULL;
    return s;
}
```

### 判断空栈
```c
int isEmpty(Stack *s)
{
    if (s->next == NULL)
    {
        printf("栈为空\n");
        return 1;
    }
    else
        return 0;
}
```

### 进栈/压栈
```c
int push(Stack *s, ElemType e) // 进栈/压栈
{
    Stack *p = (Stack *)malloc(sizeof(Stack));
    p->data = e;
    p->next = s->next;//这就是头插法
    s->next = p;
    return 1;
}
```

### 出栈
```c
int pop(Stack *s, ElemType *e) // 第二个参数可获取出栈地址
{
    if (s->next == NULL)
    {
        printf("栈为空\n");
        return 0;
    }
    *e=s->next->data;
    Stack *q=s->next;
    s->next=q->next;
    free(q);
    return 1;
}
```

### 获取栈顶元素
```c
int getTop(Stack *s, ElemType *e)
{
    if (s->next == NULL)
    {
        printf("栈为空\n");
        return 0;
    }
    *e = s->next->data;
    return 1;
}
```

# 队列
## 队列的顺序结构
### 定义
```c
#define MAXSIZE 100
typedef int ElemType;
typedef struct
{
    ElemType data[MAXSIZE];
    int front;
    int rear;
} Queue;
```

### 初始化 
```c
void initQueue(Queue *Q)
{
    Q->front = 0;
    Q->rear = 0;
}
```

### 判断空队列
```c
int isEmpty(Queue *Q)
{
    if (Q->front == Q->rear)
    {
        printf("队列为空\n");
        return 1;
    }
    else
        return 0;
}
```

### 出队
```c
ElemType dequeue(Queue *Q) // 出队
{
    if (Q->front == Q->rear)
    {
        printf("队列为空\n");
        return 1;
    }
    ElemType e = Q->data[Q->front];
    Q->front++; // 出队核心操作
    return e;
}
```

### 调整队列
```c
int queueFull(Queue *Q) // 判断队尾，调整队列
{
    if (Q->front > 0)
    {
        int step = Q->front;
        for (int i = Q->front; i <= Q->rear; i++)
        {
            Q->data[i - step] = Q->data[i];
        }
        Q->front = 0;
        Q->rear = Q->rear - step;
        return 0;
    }
    else
    {
        printf("队列已满\n");
        return 1;
    }
}
```

### 入队
```c
int equeue(Queue *Q, ElemType x) // 入队
{
    if (Q->rear >= MAXSIZE)
    {
        if (queueFull(Q))
            return 0;
    }
    Q->data[Q->rear] = x;
    Q->rear++;
    return 1;
}
```

### 获取队头元素
```c
int getFront(Queue *Q, ElemType *x)
{
    if (Q->front == Q->rear)
    {
        printf("队列为空\n");
        return 0;
    }
    *x = Q->data[Q->front];
    return 1;
}
```

### 动态分配内存
```c
typedef struct 
{
	ElemType *data;
	int front;
	int rear;
}Queue;

Queue *initQueue()
{
	Queue *q=(Queue *)malloc(sizeof(Queue));
	q->data=(ElemType *)malloc(sizeof(ElemType)*MAXSIZE);
	q->front=0;
	q->rear=0;
	return q;
}
```

## 循环队列
### 入队
```c
int equeue(Queue *Q,ElemType e)
{
	if((Q->rear + 1) % MAXSIZE == Q->front)//判断循环队列是否已满
	{
		printf("队列已满\n");
		return 0;
	}
	Q->data[Q->rear] = e;
	Q->rear = (Q->rear + 1) % MAXSIZE;//队尾指针向后移动一位
	return 1;
}
```
>[!warning]
>注意：循环队列无法占满

### 出队
```c
int dequeue(Queue *Q,ElemType *e)
{
	if(Q->front == Q->rear)
	{
		printf("队列为空\n");
		return 0;
	}
	*e = Q->data[Q->front];
	Q->front = (Q->front + 1) % MAXSIZE;//对头前进一位
	return 1;
}
```

### 动态分配内存
```c
typedef struct
{
	ElemType *data;
	int front;
	int rear;
}Queue;

Queue *initQueue()
{
	Queue *q = (Queue *)malloc(sizeof(Queue));
	q->data = (ElemType *)malloc(sizeof(ElemType) * MAXSIZE);
	q->front = 0;
	q->rear = 0;
	return q;
}
```

## 队列的链式结构
### 定义
```c
typedef int ElemType;
typedef struct QueueNode
{
    ElemType data;
    struct QueueNode *next;
} QueueNode;
  
typedef struct
{
    QueueNode *front;
    QueueNode *rear;
} Queue;
```

### 初始化
```c
Queue *initQueue()
{
    Queue *q = (Queue *)malloc(sizeof(Queue));
    QueueNode *node = (QueueNode *)malloc(sizeof(QueueNode));
    node->data = 0;
    node->next = NULL;
    q->front = node;
    q->rear = node;
    return q;
}
```

### 判断空队列
```c
int isEmpty(Queue *q)
{
    if (q->front == q->rear)
        return 1;
    else
        return 0;
}
```

### 入队
```c
void equeue(Queue *q, ElemType e) // 入队
{
    QueueNode *node = (QueueNode *)malloc(sizeof(QueueNode));
    node->data = e;
    node->next = NULL;
    q->rear->next = node;
    q->rear = node;
}
```

### 出队
```c
void dequeue(Queue *q, ElemType *e) // 出队
{
    QueueNode *node = q->front->next; // 指向头节点的下一个
    *e = node->data;
    q->front->next = node->next;
    if (q->rear == node)
        q->rear = q->front;
    free(node);
} 
```

# 递归
在函数调用过程中，调用自己
>[!note]
>递归在本质上其实是对栈的运用

## 计算1~n的和(递归)
```c
int fun(int n)
{
    if (n == 1)
        return 1;
    else
        return fun(n - 1) + n;
}
```

## 求斐波那契数列第n项值(递归)
```c
int fun(int n)
{
    if (n == 1 || n == 2)
        return 1;
    else
        return fun(n - 1) + fun(n - 2);
}
```
>[!note]
>斐波那契数列，又称黄金分割数列，又称为“兔子数列”，其数值为：1，1，2，3，5，8，13，21，34……


---

下一节：[[07.树]]