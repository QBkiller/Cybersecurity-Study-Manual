# 概念
##   查找表
是由一组具有相同数据类型的数据元素组成的集合，这些元素通常保存在一张结构化的数据表中，用于支持对其中元素的查找操作。

## 关键字
数据元素中能唯一标识该元素的属性值，查找时就是通过关键字来定位对应的数据元素的。

## 查找
在查找表中根据给定的 “关键字” 找出对应数据元素的过程。

## 平均查找长度
是指在一种查找方法下，查找一个元素所需要比较的关键字的平均次数，是衡量查找算法效率的一个重要指标。它通常分为两种情况来讨论：查找成功和查找失败。

# 算法
## 线性表的查找-顺序查找
```c
//顺序查找函数
int search(int* data, int len, int value)
{
    //data:查找表  n:表中元素个数  value:要查找的内容
    for (int i = 0; i < len; i++)
    {
        //逐个比对表中元素与要查找数据是否一致
        if (data[i] == value)
            return i;//返回找到的元素下标
    }
    return -1;//没有查到返回-1
}
```

## 线性表的查找-折半查找（二分查找）
### 概念
1.假设查找表的起始下标为 low，结束下标为 high
2.计算中间下标：`mid = (low + high) / 2`（向下取整，例如 4.5，取 4）
3.如果关键字等于`a[mid]`，查找成功，返回下标
4.如果关键字小于`a[mid]`，则在左半部分继续查找，令 `high = mid - 1`
5.如果关键字大于`a[mid]`，则在右半部分继续查找，令 `low = mid + 1`

### 算法
```c
int binary_search(int* data, int len, int value)
{
    //data:查找表  n:表中元素个数  value:要查找的内容
    int low = 0; //查找表的起始下标为low
    int high = len - 1; //假设查找表的结束下标为high
    int mid;
    while (low <= high)
    {
        mid = (low + high) / 2; //计算中间下标：mid = (low + high) / 2
        if (value > data[mid])
        {
            low = mid + 1; //如果关键字大于a[mid]，则在右半部分继续查找，令low = mid + 1
        }
        else if(value < data[mid])
        {
            high = mid - 1; //如果关键字小于data[mid]，则在左半部分继续查找，令high = mid - 1
        }
        else
        {
            return mid; //如果关键字等于data[mid]，查找成功，返回下标
        }
    }
    return -1;
}
```

## 二叉排序树
### 概念
二叉排序树（Binary Search Tree，BST）是一种特殊的二叉树，它通过巧妙的节点排列方式，实现了 “查找效率高、插入删除灵活” 的目标，它满足以下特性：
1. 对于树中任意一个节点，其左子树上所有节点的值都小于该节点的值
2. 对于树中任意一个节点，其右子树上所有节点的值都大于该节点的值，并且左右子树本身也都是一棵二叉排序树

>[!note]
>构造二叉排序树的目的，并不是为了排序，而是为了提高查找、插入以及删除关键字的速度。

### 二叉排序树-查找
```c
/*
* 查找二叉排序树中是否包含指定值 value
* 参数 T：当前子树根节点
* 参数 value：要查找的值
* 参数 parent：当前节点的父节点
* 参数 pos：指针变量，用于返回找到的节点
* 返回值：1 表示找到，0 表示未找到
*/
int search_bst(BiTree T, int value, BiTree parent, BiTree *pos)
{
    if (T == NULL)
    {
        *pos = parent; // 递归到空节点，查找失败，将父节点返回（本书后面内容可用于插入）
        return 0;
    }
    if (T->data == value)
    {
        *pos = T; // 找到目标值
        return 1;
    }
    if (T->data > value)
    {
        return search_bst(T->lchild, value, T, pos); // 要查找的值比当前节点小，往左子树找
    }
    else
    {
        return search_bst(T->rchild, value, T, pos); // 要查找的值比当前节点大，往右子树找
    }
}
```

### 二叉排序树-插入
```c
// 向二叉排序树中插入一个值
// 如果值已存在，插入失败，返回 0；否则插入成功，返回 1
int insert_bst(BiTree *T, int value)
{
    BiTree parent, pos;  // parent 用于辅助 search_bst, pos 表示插入位置或已存在的位置
    BiTree curr;

    // 查找插入位置
    int status = search_bst(*T, value, NULL, &pos);
    if (status == 0)
    {
        // 如果未找到，创建新结点
        curr = (BiTree)malloc(sizeof(TreeNode));
        curr->data = value;
        curr->lchild = NULL;
        curr->rchild = NULL;
        // 如果树为空，新结点作为根结点
        if (pos == NULL)
        {
            *T = curr;
        }
        // 插入为左子结点
        else if (value < pos->data)
        {
            pos->lchild = curr;
        }
        // 插入为右子结点
        else
        {
            pos->rchild = curr;
        }
        return 1;
    }
    else
    {
        // 如果已存在，不插入
        return 0;
    }
}
```

### 二叉排序树-删除
#### 概念
- 情况一：删除的结点是叶子节点（没有左右孩子）
	直接将其从树中移除即可，不影响其它结构。
- 情况二：删除的结点只有一个孩子（左孩子或右孩子）
    让其唯一的子节点 “顶替” 它的位置，保持排序特性不变。
- 情况三：删除的结点有两个孩子
    使用右子树中最小的结点代替，或使用左子树中最大的结点代替。

#### 算法
```c
// 递归查找并删除目标节点
int delete_bst(BiTree *T, int value)
{
    if (*T == NULL)
    {
        printf("not found!\n");
        return 0;
    }
    else
    {
        if ((*T)->data == value)
        {
            return delete(T);
        }
        else if ((*T)->data > value)
        {
            return delete_bst(&(*T)->lchild, value);
        }
        else
        {
            return delete_bst(&(*T)->rchild, value);
        }
    }
}

// 真正执行删除的操作（分三种情况）
int delete(BiTree *d)
{
    BiTree temp, record;

    if ((*d)->rchild == NULL)
    {
        // 情况1：只有左子树或无子节点
        temp = *d;
        *d = (*d)->lchild;
        free(temp);
    }
    else if ((*d)->lchild == NULL)
    {
        // 情况2：只有右子树
        temp = *d;
        *d = (*d)->rchild;
        free(temp);
    }
    else
    {
        // 情况3：左右子树都有，找左子树中最大的节点替换
        temp = *d;
        record = (*d)->lchild;
        while (record->rchild != NULL)
        {
            temp = record;
            record = record->rchild;
        }
        // 替换当前值
        (*d)->data = record->data;
        // 删除替代节点
        if (temp == *d)
        {
            temp->rchild = record->lchild;
        }
        else
        {
            temp->lchild = record->lchild;
        }
        free(record);
    }
    return 1;
}
```

## 平衡二叉树（AVL 树）
平衡二叉树（Balanced Binary Tree）：又称 AVL 树，是一种二叉排序树，任意一个节点的左子树与右子树的高度之差的绝对值不超过 1。
平衡因子（Balance Factor）：平衡因子是衡量节点平衡程度的指标。
（计算公式：**平衡因子 = 左子树的高度 - 右子树的高度**）

平衡二叉树平衡调整：

| 失衡类型 | 失衡点      | 调整方式    |
| ---- | -------- | ------- |
| LL 型 | 祖先结点的左子树 | 右旋      |
| RR 型 | 祖先结点的右子树 | 左旋      |
| LR 型 | 左子树的右子树  | 左旋 + 右旋 |
| RL 型 | 右子树的左子树  | 右旋 + 左旋 |

## B 树（B - 树）
B 树是 “多路版本” 的平衡查找树，或者叫 “平衡多叉树”。
如果将二叉排序树看成是 “每个节点最多两个分支” 的树，那么 B 树允许每个节点有多个关键字和多个孩子，这种结构能有效压缩树的高度。

一个 m 阶的 B 树满足以下性质：
1. **节点子节点上限**：每个节点最多有 `m` 个孩子。
2. **非根非叶节点下限**：每个非根非叶子节点至少有 `⌈m/2⌉` 个孩子。
3. **关键字与子节点数量关系**：每个非叶子节点有 `k` 个孩子，就有 `k-1` 个关键字。
4. **关键字有序性**：关键字按照中序遍历是有序的。

## B + 树
B + 树是 B 树的一个变种，是在数据库系统、文件系统中应用最广泛的一种平衡查找树结构。它的本质仍然是 “分层、多分支、平衡” 的，但与 B 树相比，它在结构上做了两处关键性的优化：
1. **关键字存储优化**：所有关键字只出现在叶子结点中，非叶子结点仅用于索引。
2. **叶子节点连接优化**：所有叶子结点按大小顺序通过指针连接，形成有序链表。

## 散列查找
### 散列表
用一个 “函数” 直接计算出数据存储的位置，从而实现快速查找。

### 散列函数
根据音译，通常也被称作哈希函数，是一种将关键字（Key）映射到散列表中某个地址（位置）的函数。它的作用是根据关键字，快速计算出该元素应该存储的位置。

### 冲突
当两个不同的关键字通过散列函数计算后，得到相同的结果值（地址），它们就会被映射到散列表的同一个位置，这种现象称为哈希冲突或散列冲突（简称 “冲突”）。

---
下一节：[[10.排序]]






