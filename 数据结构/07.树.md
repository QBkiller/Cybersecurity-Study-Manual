# 定义
树是一个或多个节点的有限集合。

* **结点**：树中的一个独立单元
* **结点的度**：结点拥有的子树数称为结点的度
* **树的度**：树内各结点度的最大值
* **叶子**：度为0的结点或终端结点
* **双亲和孩子**：结点的子树的根称为该结点的孩子，相应的，该结点称为孩子的双亲
* **层次**：结点的层次从根节点开始定义，根为第一层，根的孩子为第二层，以此类推

## 二叉树
二叉树是n个结点所构成的集合。

对于非空二叉树T:
* 有且仅有一个称为根的结点
* 二叉树的每个系欸但最多只有两颗子树
* 二叉树的子树有左右之分，其次序不能任意颠倒

### 满二叉树
==深度为K且含有$2^k-1$个结点的二叉树==

### 完全二叉树
==深度为K，有n个结点的二叉树，当且仅当其每一个系欸但都与深度K的满二叉树中编号从1至n的结点一一对应==

>[!note]
>判断满二叉树：
>**没有左子树，不能有右子树，上一层没有铺满，不能有下一层**

### 线索二叉树
==通过遍历可以的到二叉树的线性排列，但是线性序列只有在遍历时才能得到，将二叉树**线索化**得到线索二叉树可以解决这个问题==

**线索化**：利用叶节点的空余空间记录前驱与后继

特点：
1.右孩子为NULL的结点，用来记录==后继==；
  左孩子为NULL的节点，用来记录==前驱==
2.头节点的lchild指向二叉树的根
3.头节点的rchild指向遍历的最后一个节点
4.第一个节点的lchild指向头节点
5.最后一个节点的rchild指向头节点

### 哈夫曼树
==带权路径长度WPL最小的二叉树称为哈夫曼树==
**结点的权**：在实际应用中，给树中的结点赋予代表某种含义的数值
**结点的带权路径长度**：从该结点到树根之间的路径长度与该结点权的乘积
**树的带权路径长度（WPL）**：树中所有叶结点的带权路径长度之和
# 二叉树的顺序结构
对于这种结构而言，除了满二叉树和完全二叉树外，其他场景比较浪费空间。

# 二叉树的链式结构
## 定义
```c
typedef char ElemType;
typedef struct TreeNode
{
	ElemType data;
	struct TreeNode *lchild;
	struct TreeNode *rchild;
} TreeNode;
  
typedef TreeNode *BiTree;
```

## 前序遍历
```c
void preOrder(BiTree T)
{
	if (T == NULL)
		return;
	printf("%c", T->data);
	preOrder(T->lchild);
	preOrder(T->rchild);
}
```

## 中序遍历
```c
void inOrder(BiTree T)
{
	if (T == NULL)
		return;
	inOrder(T->lchild);
	printf("%c", T->data);
	inOrder(T->rchild);
}
```

## 后序遍历
```c
void postOrder(BiTree T)
{
	if (T == NULL)
		return;
	postOrder(T->lchild);
	postOrder(T->rchild);
	printf("%c", T->data);
}
```
>[!note]
>已知前序遍历和后序遍历是无法推导出二叉树的！！！

## 生成树
```c
char str[] = "ABDH#K###E##CFI###G#J##";
int idx = 0;

void creatTree(BiTree *T)
{
	ElemType ch;
	ch = str[idx++];

	if (ch == '#')
		*T = NULL;
	else
	{
		*T = (BiTree)malloc(sizeof(TreeNode));
		(*T)->data = ch;
		creatTree(&(*T)->lchild);
		creatTree(&(*T)->rchild);
	}
}
```

# 线索二叉树的链式结构
## 定义
```c
typedef char ElemType;
  
typedef struct ThreadNode
{
	ElemType data;
	struct ThreadNode *lchild;
	struct ThreadNode *rchild;
	int ltag; // 判断前驱
	int rtag; // 判断后继
} ThreadNode;

typedef ThreadNode *ThreadTree;
```

## 生成树
```c
char str[] = "ABDH##I##EJ###CF##G##";
int idx = 0;
  
ThreadTree prev; // 创建一个prev变量，表示上一个访问的节点
  
void createTree(ThreadTree *T)
{
	ElemType ch;
	ch = str[idx++];
	if (ch == '#')
		*T = NULL;
	else
	{
		*T = (ThreadTree)malloc(sizeof(ThreadNode));
		(*T)->data = ch;
		createTree(&(*T)->lchild);

		if ((*T)->lchild != NULL)
			(*T)->ltag = 0;

		createTree(&(*T)->rchild);
  
		if ((*T)->rchild != NULL)
			(*T)->rtag = 0;
	}
}
```

## 开始线索化
```c
void inOrderThreading(ThreadTree *head, ThreadTree T)
{
    // 头节点
    *head = (ThreadTree)malloc(sizeof(ThreadNode));
    (*head)->ltag = 0;
    (*head)->rtag = 1;
    (*head)->rchild = (*head); // 暂时指向自己
  
    if (T == NULL)
        (*head)->lchild = *head;
    else
    {
        (*head)->lchild = T;
        prev = (*head);
        threading(T);

        // 最后一个节点线索化
        prev->rchild = *head;
        prev->rtag = 1;
  
        // 头节点右孩子指向最后一个节点
        (*head)->rchild = prev;
    }
}
```

## 具体线索化
```c
void threading(ThreadTree T)
{
    if (T != NULL)
    {
        threading(T->lchild);
        if (T->lchild == NULL)
        {
            T->ltag = 1;
            T->lchild = prev;
        }
        if (prev->rchild == NULL)
        {
            prev->rtag = 1;
            prev->rchild = T;
        }
        prev = T;
        threading(T->rchild);
    }
}
```

## 线索遍历
```c
void inOrder(ThreadTree T)
{
    ThreadTree curr;
    curr = T->lchild;

    while (curr != T)
    {
        while (curr->ltag == 0)
        {
            curr = curr->lchild;
        }
  
        printf("%c", curr->data);

        while (curr->rtag == 1 && curr->rchild != T)
        {
            curr = curr->rchild;
            printf("%c", curr->data);
        } 
        curr = curr->rchild;
    }
    printf("\n");
}
```

# 二叉树的层序遍历
```c
int maxDepth(TreeNode *root)
{
    if (root == NULL)
        return 0;
  
    int depth = 0;
    Queue *q = initQueue();
    equeue(q, root);
  
    while (!isEmpty(q))
    {
        int count = queueSize(q);
        while (count > 0)
        {
            TreeNode *curr;
            dequeue(q, &curr);
            if (curr->lchild != NULL)
                equeue(q, curr->lchild);
            if (curr->rchild != NULL)
                equeue(q, curr->rchild);
  
            count--;
        }
        depth++;
    }
    return depth;
}
```

---

下一节：[[08.图]]