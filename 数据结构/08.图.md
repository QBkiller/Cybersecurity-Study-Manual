# 概念
是由==顶点==的又穷非空集合和顶点之间==边==的集合组成的。
通记为G(V,E)，其中G表示一个图，V是图G中顶点的集合，E是边的集合。
V(G)和E(G)通常分别表示图G的顶点集合和边集合。
>[!note]
>对于图这种数据结构，不允许没有顶点，但边集可以为空。

## 有向图与无向图
![[Pasted image 20251208183530.png]]

## 路径和路径长度
* 路径：从一个顶点开始，经过一系列的边到达另外一个顶点形成的顶点序列。
* 路径长度：路径上边的条数。
* 回路（环）：起点和终点相同的路径。

## 顶点的度
* 度：在无向图中，顶点的度指的是与顶点相关联边的数目。
* 入度：在有向图中，对于顶点v，箭头指向v的边的数目。
* 出度：在有向图中，对于顶点v，从该顶点出发的边的数目。

## 度与边的关系
* 在无向图中，图中所有顶点度之和等于边数的两倍。
* 在有向图中，所有顶点的出度之和与入度之和相等，弧头之和与弧尾之和相等。

## 连通图
* 连通：在无向图中，如果从顶点v到顶点w有路径，测称顶点v到顶点w是连通的。
* 如果对于途中任意两个顶点都是连通的，则称此图为连通图。

## 连通分量
**无向图中的极大连通子图称为连通分量**
* 连通分量为子图
* 子图为连通图
* 连通图含有极大顶点数
* 具有极大顶点数的连通子图包含依附于这些顶点的所有边。

## 强连通分量
* 强连通图：在有向图中，对于每一对顶点v和w，从v到w和从w到v都有路径，则称该有向图是强连通图。
* 有向图中的极大强连通子图称为有向图的强连通分量。

## 生成树
* 生成树：指含有图中全部顶点的极小连通子树
>[!note]
>包含所有顶点n，但只有足以构成一棵树的n-1条边

## 边的权和网
* 在一个图中，每条边可以标注上一个代表某种含义的数值，该数值称为这个边的权值网。
* 边上带的权值的图称为带权图。

# 图的存储结构

## 邻接矩阵-无向
![[Pasted image 20251208190427.png]]

## 邻接矩阵-有向
![[Pasted image 20251208190508.png]]

## 邻接矩阵-带权值
![[Pasted image 20251208190533.png]]

## 邻接表-无向
![[Pasted image 20251208190557.png]]

## 邻接表-有向
![[Pasted image 20251208190626.png]]

## 逆邻接表
![[Pasted image 20251208190649.png]]

## 邻接表-带权值
![[Pasted image 20251208190747.png]]

## 十字链表
![[Pasted image 20251208190827.png]]

## 邻接多重表
![[Pasted image 20251208190925.png]]

# 算法
## 深度优先遍历DFS
### 图的定义
```c
typedef char Vertextype;
typedef int Edgetype;

#define MAXSIZE 100
  
typedef struct
{
    Vertextype vertex[MAXSIZE];
    Edgetype arc[MAXSIZE][MAXSIZE];
    int vertex_num;
    int edge_num;
}Mat_Grph;
  
int visited[MAXSIZE];//记录访问过的顶点
```

### 创建图
```c
void creat_graph(Mat_Grph *G)
{
    G->vertex_num=9;
    G->edge_num=15;
    G->vertex[0]='A';
    G->vertex[1]='B';
    G->vertex[2]='C';
    G->vertex[3]='D';
    G->vertex[4]='E';
    G->vertex[5]='F';
    G->vertex[6]='G';
    G->vertex[7]='H';
    G->vertex[8]='I';

    for(int i=0;i<G->vertex_num;i++)
    {
        for(int j=0;j<G->vertex_num;j++)
        {
            G->arc[i][j]=0;
        }
    }
  
    G->arc[0][1]=1;
    G->arc[0][5]=1;
    G->arc[1][2]=1;
    G->arc[1][6]=1;
    G->arc[1][8]=1;
  
    G->arc[2][3]=1;
    G->arc[2][8]=1;

    G->arc[3][4]=1;
    G->arc[3][6]=1;
    G->arc[3][7]=1;
    G->arc[3][8]=1;

    G->arc[4][5]=1;
    G->arc[4][7]=1;

    G->arc[5][6]=1;
  
    G->arc[6][7]=1;
  
    for(int i=0;i<G->vertex_num;i++)
    {
        for(int j=0;j<G->vertex_num;j++)
        {
            G->arc[j][i]=G->arc[i][j];
        }
    }
}
```

### 深度优先DFS
```c
void dfs(Mat_Grph G,int i)
{
    visited[i]=1;
    printf("%c\n",G.vertex[i]);
  
    for(int j=0;j<G.vertex_num;j++)
    {
        if(G.arc[i][j]==1&&visited[j]==0)
        {
            dfs(G,j);
        }
    }
}
```

## 广度优先遍历BFS
### 图的定义
```c
typedef char Vertextype;
typedef int Edgetype;

#define MAXSIZE 100
  
typedef struct
{
    Vertextype vertex[MAXSIZE];
    Edgetype arc[MAXSIZE][MAXSIZE];
    int vertex_num;
    int edge_num;
}Mat_Grph;
  
int visited[MAXSIZE];//记录访问过的顶点
int front =0;
int rear =0;
int queue[MAXSIZE];
```

### 创建图
```c
void creat_graph(Mat_Grph *G)
{
    G->vertex_num=9;
    G->edge_num=15;
    G->vertex[0]='A';
    G->vertex[1]='B';
    G->vertex[2]='C';
    G->vertex[3]='D';
    G->vertex[4]='E';
    G->vertex[5]='F';
    G->vertex[6]='G';
    G->vertex[7]='H';
    G->vertex[8]='I';

    for(int i=0;i<G->vertex_num;i++)
    {
        for(int j=0;j<G->vertex_num;j++)
        {
            G->arc[i][j]=0;
        }
    }
  
    G->arc[0][1]=1;
    G->arc[0][5]=1;
    G->arc[1][2]=1;
    G->arc[1][6]=1;
    G->arc[1][8]=1;
  
    G->arc[2][3]=1;
    G->arc[2][8]=1;

    G->arc[3][4]=1;
    G->arc[3][6]=1;
    G->arc[3][7]=1;
    G->arc[3][8]=1;

    G->arc[4][5]=1;
    G->arc[4][7]=1;

    G->arc[5][6]=1;
  
    G->arc[6][7]=1;
  
    for(int i=0;i<G->vertex_num;i++)
    {
        for(int j=0;j<G->vertex_num;j++)
        {
            G->arc[j][i]=G->arc[i][j];
        }
    }
}
```

### 广度优先BFS
```c
void bfs(Mat_Grph G,int i)
{
    visited[i]=1;
    printf("%c\n",G.vertex[i]);
    queue[rear]=i;
    rear++;
  
    while (rear!=front)
    {
        i=queue[front];
        front++;
        for(int j=0;j<G.vertex_num;j++)
        {
            if(G.arc[i][j]==1&&visited[j]==0)
            {
                visited[j]=1;
                printf("%c\n",G.vertex[j]);
                queue[rear]=j;
                rear++;
            }
        }
    }
}
```

## 最小生成树-普里姆（Prim）
```c
void prim(Mat_Grph *G) {
    int i, j, k; // 作为下标使用
    int min;
    int weight[MAXSIZE];    // 作为候选边使用
    int vex_index[MAXSIZE]; // 最特殊的数组，值表示出发点，下标表示到达点

    // 先从顶点A开始
    weight[0] = 0;
    vex_index[0] = 0;

    for (i = 1; i < G->vertex_num; i++) { // 同样初始化
        weight[i] = G->arc[0][i];         // 开始载入候选边
        vex_index[i] = 0;
    }
    // 找到最短的候选边，并将两个点相连（通过vex_index）
    for (int i = 1; i < G->vertex_num; i++) {
        min = MAX;
        j = 0;
        k = 0;

        while (j < G->vertex_num) {
            if (weight[j] != 0 && weight[j] < min) {
                min = weight[j];
                k = j; // 将j的值传给k，让k作为下标输出
            }
            j++;
        }

        printf("(%c,%c)\n", G->vertex[vex_index[k]], G->vertex[k]);
        weight[k] = 0; // 表示此候选边无法再度使用

        // 寻找新节点的待选路径
        for (j = 0; j < G->vertex_num; j++) {
            // 将weight候选边与新节点的候选边比较，更新weight候选边
            if (weight[j] != 0 && G->arc[k][j] < weight[j]) {
                weight[j] = G->arc[k][j];
                vex_index[j] = k;
            }
        }
    }
}
```

## 最小生成树-克鲁斯卡尔（kruskal）
### 定义
```c
#include <stdio.h>

typedef char Vertextype;
typedef int EdgeType;

#define MAXSIZE 100
#define MAXEDGE 200
#define MAX 0x7fffffff // 作为∞

typedef struct {
    Vertextype vertex[MAXSIZE];
    EdgeType arc[MAXSIZE][MAXSIZE];
    int vertex_num;
    int edge_num;
} Mat_Grph;

typedef struct {
    int begin;
    int end;
    int weight;
} Edge;
```

### 算法
```c
// 完成交换，C语言真麻烦
void swap(Edge *edges, int i, int j) {
    int temp;
    temp = edges[i].begin;
    edges[i].begin = edges[j].begin;
    edges[j].begin = temp;

    temp = edges[i].end;
    edges[i].end = edges[j].end;
    edges[j].end = temp;

    temp = edges[i].weight;
    edges[i].weight = edges[j].weight;
    edges[j].weight = temp;
}

// 对edges进行升序的排序
void sortEdges(Edge edges[], int edge_num) {
    for (int i = 0; i < edge_num; i++) {
        for (int j = i + 1; j < edge_num; j++) {
            if (edges[i].weight > edges[j].weight) {
                swap(edges, i, j);
            }
        }
    }
}

int find(int *parent, int index) { // 循环查找对应的顶点
    while (parent[index] > 0) {
        index = parent[index];
    }
    return index;
}

void kruskal(Mat_Grph G) {
    Edge edges[MAXEDGE];
    int k = 0; // 初始化

    // edges赋值
    for (int i = 0; i < G.vertex_num; i++) {
        for (int j = i + 1; j < G.vertex_num; j++) {
            if (G.arc[i][j] < MAX) {
                edges[k].begin = i;
                edges[k].end = j;
                edges[k].weight = G.arc[i][j];
                k++;
            }
        }
    }

    sortEdges(edges, G.edge_num);

    int parent[MAXSIZE]; // 表示点之间的关系

    for (int i = 0; i < G.vertex_num; i++) {
        parent[i] = 0; // 初始化
    }

    int n, m;
    for (int i = 0; i < G.edge_num; i++) {
        n = find(parent, edges[i].begin); // 通过最小边依次寻找相关顶点
        m = find(parent, edges[i].end);

        if (n != m) { // 确保不会出现回路
            parent[n] = m;
            printf("(%c,%c) %d\n", G.vertex[edges[i].begin],
                   G.vertex[edges[i].end], edges[i].weight);
        }
    }
}
```
## 最短路径-迪杰斯特拉（dijkstra）
### 图的定义
```c
typedef int VertexType;
typedef int EdgeType;

#define MAXSIZE 100
#define MAXEDGE 200
#define MAX 0x10000 // 近似最大，需要和其他值进行运算

typedef struct {
    VertexType vertex[MAXSIZE];
    EdgeType arc[MAXSIZE][MAXSIZE];
    int vertex_num;
    int edge_num;
} Mat_Graph;
```

### 创建图
```c
void creatGraph(Mat_Graph *G) {
    G->vertex_num = 9;
    G->edge_num = 16;

    for (int i = 0; i < G->vertex_num; i++) {
        G->vertex[i] = i; // 利用for循环赋值V0~V8
    }
    for (int i = 0; i < G->vertex_num; i++) { // 创建关系图
        for (int j = 0; j < G->vertex_num; j++) {
            if (i == j) {
                G->arc[i][j] = 0;
            } else {
                G->arc[i][j] = MAX;
            }
        }
    }

    // 开始赋值权重weight
    G->arc[0][1] = 1;
    G->arc[0][2] = 5;

    G->arc[1][2] = 3;
    G->arc[1][3] = 7;
    G->arc[1][4] = 5;

    G->arc[2][4] = 1;
    G->arc[2][5] = 7;

    G->arc[3][4] = 2;
    G->arc[3][6] = 3;

    G->arc[4][5] = 3;
    G->arc[4][6] = 6;
    G->arc[4][7] = 9;

    G->arc[5][7] = 5;

    G->arc[6][7] = 2;
    G->arc[6][8] = 7;

    G->arc[7][8] = 4;

    for (int i = 0; i < G->vertex_num; i++) {
        for (int j = i; j < G->vertex_num; j++) {
            G->arc[j][i] = G->arc[i][j]; // 进行对称赋值
        }
    }
}
```

### dijkstra算法
```c
int choose(int distance[], int found[], int vertex_num) {
    int min = MAX;
    int minPos = -1;
    for (int i = 0; i < vertex_num; i++) {
        if (distance[i] < min && found[i] == 0) {
            min = distance[i];
            minPos = i;
        }
    }
    return minPos;
}

void dijkstra(Mat_Graph G, int begin) {
    int found[MAXSIZE];    // 用于判断顶点是否走过，走过为1,未走为0
    int path[MAXSIZE];     // 里面存储距离下标顶点最近的顶点位置
    int distance[MAXSIZE]; // 下标顶点到起始顶点的距离
    for (int i = 0; i < G.vertex_num; i++) { // 分别对三个数组进行初始化
        found[i] = 0;
        path[i] = -1;
        distance[i] = G.arc[begin][i]; // 导入从起始顶点开始的路径
    }

    found[begin] = 1;
    distance[begin] = 0;

    int next; // 存放下一个要观察的顶点
    for (int i = 1; i < G.vertex_num; i++) {
        next = choose(distance, found, G.vertex_num);
        found[next] = 1;
        for (int j = 0; j < G.vertex_num; j++) {
            if (found[j] == 0) {
                if (distance[next] + G.arc[next][j] < distance[j]) {
                    distance[j] = distance[next] + G.arc[next][j];
                    path[j] = next;
                }
            }
        }
    }

    // 输出
    for (int i = 1; i < G.vertex_num; i++) {
        printf("V0->V%d : %d\n", i, distance[i]);

        int j = i;
        printf("V%d<-", i);
        while (path[j] != -1) {
            printf("V%d<-", path[j]);
            j = path[j];
        }
        printf("V0\n");
    }
}
```

## 最短路径-弗洛伊德（Floyd）
```c
 void floyd(Mat_Graph G) {
    int path[MAXSIZE][MAXSIZE];     // 表示顶点之间的中转顶点
    int distance[MAXSIZE][MAXSIZE]; // 表示顶点之间的最短距离

    for (int i = 0; i < G.vertex_num; i++) {
        for (int j = 0; j < G.vertex_num; j++) {
            distance[i][j] = G.arc[i][j];
            path[i][j] = j; // 初始化
        }
    }

    // j：起始顶点 i：中转顶点 k：终止顶点
    for (int i = 0; i < G.vertex_num; i++) {
        for (int j = 0; j < G.vertex_num; j++) {
            for (int k = 0; k < G.vertex_num; k++) {
                if (distance[j][k] > distance[j][i] + distance[i][k]) {
                    distance[j][k] = distance[j][i] + distance[i][k];
                    path[j][k] = path[j][i];
                }
            }
        }
    }

    int k;
    for (int i = 0; i < G.vertex_num; i++) {
        for (int j = i + 1; j < G.vertex_num; j++) {
            printf("V%d->V%d weight: %d ", i, j, distance[i][j]);
            k = path[i][j];
            printf("path:V%d", i);
            while (k != j) {
                printf("->V%d", k);
                k = path[k][j];
            }
            printf("->V%d\n", j);
        }
        printf("\n");
    }
}
```

## 拓扑排序
### 概念
在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先级，这样的有向图为顶点表示活动的网，称为AOV网。
拓扑排序：持续寻找入度为0的顶点，然后出栈，入栈。

### 定义
```c
#include <stdio.h>
#include <stdlib.h>

typedef int VertexType;
typedef int EdgeType;

#define MAXSIZE 100

typedef struct {
    VertexType vertex[MAXSIZE];
    EdgeType arc[MAXSIZE][MAXSIZE];
    int vertex_num;
    int edge_num;
} Mat_Graph;

typedef struct EdgeNode {
    int edge_vex;
    struct EdgeNode *next;
} EdgeNode;

typedef struct VertexNode {
    int in;
    VertexType data;
    EdgeNode *head;
} VertexNode; // 定义一个链表，作为邻接表使用

typedef VertexNode Adj_List[MAXSIZE]; // Adj_List为邻接表

typedef struct {
    Adj_List adj_list;
    int vertex_num;
    int edge_num;
} Adj_Graph;

typedef Adj_Graph *Adj_List_Graph;

int top = -1;
int stack[MAXSIZE]; // 一个简单的栈

void push(int e) {
    if (top > MAXSIZE) {
        printf("栈满\n");
        return;
    }
    top++;
    stack[top] = e;
}

int pop() {
    if (top == -1) {
        printf("栈空\n");
        return 0;
    }
    int elem = stack[top];
    top--;
    return elem;
}

int is_empty() {
    if (top == -1)
        return 0;
    else
        return 1;
}

void create_graph(Mat_Graph *G) {
    G->vertex_num = 14;
    G->edge_num = 20;

    for (int i = 0; i < G->vertex_num; i++) {
        G->vertex[i] = i;
    }
    for (int i = 0; i < G->vertex_num; i++) {
        for (int j = 0; j < G->vertex_num; j++) {
            G->arc[i][j] = 0;
        }
    }

    G->arc[0][4] = 1;
    G->arc[0][5] = 1;
    G->arc[0][11] = 1;
    G->arc[1][2] = 1;
    G->arc[1][4] = 1;
    G->arc[1][8] = 1;
    G->arc[2][5] = 1;
    G->arc[2][6] = 1;
    G->arc[2][9] = 1;
    G->arc[3][2] = 1;
    G->arc[3][13] = 1;
    G->arc[4][7] = 1;
    G->arc[5][8] = 1;
    G->arc[5][12] = 1;
    G->arc[6][5] = 1;
    G->arc[8][7] = 1;
    G->arc[9][10] = 1;
    G->arc[9][11] = 1;
    G->arc[10][13] = 1;
    G->arc[12][9] = 1;
}
```

### 邻接矩阵转换为邻接表
```c
void create_adj_graph(Mat_Graph G, Adj_List_Graph *ALG) {
    EdgeNode *e;

    *ALG = (Adj_List_Graph)malloc(sizeof(Adj_Graph));
    (*ALG)->vertex_num = G.vertex_num;
    (*ALG)->edge_num = G.edge_num;

    for (int i = 0; i < G.vertex_num; i++) {
        (*ALG)->adj_list[i].in = 0;
        (*ALG)->adj_list[i].data = G.vertex[i];
        (*ALG)->adj_list[i].head = NULL; // 初始化
    }

    for (int i = 0; i < G.vertex_num; i++) {
        for (int j = 0; j < G.vertex_num; j++) {
            if (G.arc[i][j] == 1) {
                e = (EdgeNode *)malloc(sizeof(EdgeNode));
                e->edge_vex = j;
                e->next = (*ALG)->adj_list[i].head;
                (*ALG)->adj_list[i].head = e;
                (*ALG)->adj_list[j].in++; // 运用头插法创建邻接表
            }
        }
    }
}
```

### 拓扑排序
```c
void topological_sort(Adj_List_Graph ALG) {
    EdgeNode *e;
    int curr; // 保留出栈值
    int k;

    for (int i = 0; i < ALG->vertex_num; i++) {
        if (ALG->adj_list[i].in == 0) {
            push(i);
        }
    }

    while (is_empty() != 0) {
        curr = pop();
        printf("V%d->", ALG->adj_list[curr].data);
        e = ALG->adj_list[curr].head;

        while (e != NULL) {
            k = e->edge_vex;
            ALG->adj_list[k].in--;
            if (ALG->adj_list[k].in == 0) {
                push(k);
            }
            e = e->next;
        }
    }
}
```

## 关键路径
### 概念
在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称为AOE网。
etv：事件最早发生的时间，从前往后推，取最大值
ltv：事件最晚发生的时间，从后往前推，取最小值
关键路径：将etv和ltv相同的节点依次连接，得到的路径即为关键路径

### 定义
```c
typedef int VertexType;
typedef int EdgeType;

#define MAXSIZE 100
#define MAX 0x7fffffff // 看作∞

typedef struct {
    VertexType vertex[MAXSIZE];
    EdgeType arc[MAXSIZE][MAXSIZE];
    int vertex_num;
    int edge_num;
} Mat_Graph;

typedef struct EdgeNode {
    int edge_vex;
    int weight; // 新增的权重
    struct EdgeNode *next;
} EdgeNode;

typedef struct VertexNode {
    int in;
    VertexType data;
    EdgeNode *head;
} VertexNode; // 定义一个链表，作为邻接表使用

typedef VertexNode Adj_List[MAXSIZE]; // Adj_List为邻接表

typedef struct {
    Adj_List adj_list;
    int vertex_num;
    int edge_num;
} Adj_Graph;

typedef Adj_Graph *Adj_List_Graph;

void create_graph(Mat_Graph *G) {
    G->vertex_num = 10;
    G->edge_num = 13;

    for (int i = 0; i < G->vertex_num; i++) {
        G->vertex[i] = i;
    }
    for (int i = 0; i < G->vertex_num; i++) {
        for (int j = 0; j < G->vertex_num; j++) {
            if (i == j) {
                G->arc[i][j] = 0;
            } else {
                G->arc[i][j] = MAX;
            }
        }
    }

    G->arc[0][1] = 3;
    G->arc[0][2] = 4;
    G->arc[1][3] = 5;
    G->arc[1][4] = 6;
    G->arc[2][3] = 8;
    G->arc[2][5] = 7;
    G->arc[3][4] = 3;
    G->arc[4][6] = 9;
    G->arc[4][7] = 4;
    G->arc[5][7] = 6;
    G->arc[6][9] = 2;
    G->arc[7][8] = 5;
    G->arc[8][9] = 3;
}
```

### 邻接矩阵转换为邻接表
```c
void create_adj_graph(Mat_Graph G, Adj_List_Graph *ALG) {
    EdgeNode *e;

    *ALG = (Adj_List_Graph)malloc(sizeof(Adj_Graph));
    (*ALG)->vertex_num = G.vertex_num;
    (*ALG)->edge_num = G.edge_num;

    for (int i = 0; i < G.vertex_num; i++) {
        (*ALG)->adj_list[i].in = 0;
        (*ALG)->adj_list[i].data = G.vertex[i];
        (*ALG)->adj_list[i].head = NULL; // 初始化
    }

    for (int i = 0; i < G.vertex_num; i++) {
        for (int j = 0; j < G.vertex_num; j++) {
            if (G.arc[i][j] != 0 && G.arc[i][j] < MAX) {
                e = (EdgeNode *)malloc(sizeof(EdgeNode));
                e->edge_vex = j;
                e->weight = G.arc[i][j];
                e->next = (*ALG)->adj_list[i].head;
                (*ALG)->adj_list[i].head = e;
                (*ALG)->adj_list[j].in++; // 运用头插法创建邻接表
            }
        }
    }
}
```

### 关键路径
```c
void critical_path(Adj_List_Graph ALG) {
    EdgeNode *e;
    int top = -1;
    int top2 = -1;
    int stack[MAXSIZE];
    int stack2[MAXSIZE];
    int etv[MAXSIZE];
    int ltv[MAXSIZE];
    int curr; // 保留出栈值
    int k;

    for (int i = 0; i < ALG->vertex_num; i++) {
        if (ALG->adj_list[i].in == 0) {
            top++;
            stack[top] = i;
        }
    }

    for (int i = 0; i < ALG->vertex_num; i++) {
        etv[i] = 0;
    }

    while (top != -1) {
        curr = stack[top];
        top--;
        printf("V%d->", ALG->adj_list[curr].data);

        top2++;
        stack2[top2] = curr;

        e = ALG->adj_list[curr].head;

        while (e != NULL) {
            k = e->edge_vex;
            ALG->adj_list[k].in--;
            if (ALG->adj_list[k].in == 0) {
                top++;
                stack[top] = k;
            }
            if (etv[curr] + e->weight > etv[k]) {
                etv[k] = etv[curr] + e->weight;
            }
            e = e->next;
        }
    }
    printf("End\n");

    printf("etv:");
    for (int i = 0; i < ALG->vertex_num; i++) {
        printf("%d->", etv[i]);
    }
    printf("End\n");

    for (int i = 0; i < ALG->vertex_num; i++) {
        ltv[i] = etv[ALG->vertex_num - 1];
    }

    while (top2 != -1) {
        curr = stack2[top2];
        top2--;

        e = ALG->adj_list[curr].head;
        while (e != NULL) {
            k = e->edge_vex;
            if (ltv[k] - e->weight < ltv[curr]) {
                ltv[curr] = ltv[k] - e->weight;
            }
            e = e->next;
        }
    }

    printf("ltv:");
    for (int i = 0; i < ALG->vertex_num; i++) {
        printf("%d->", ltv[i]);
    }
    printf("End\n");

    for (int i = 0; i < ALG->vertex_num; i++) {
        if (etv[i] == ltv[i]) {
            printf("V%d->", i);
        }
    }
}
```
